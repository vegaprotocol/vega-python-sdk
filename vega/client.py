import base64
import json
import random
import uuid
from typing import Any, Dict, Optional

import grpc
import requests

import vega.proto.vega.api.v1.core_pb2 as core_proto
import vega.proto.vega.commands.v1.signature_pb2 as signature_proto
import vega.proto.vega.commands.v1.transaction_pb2 as transaction_proto
from vega.auth import Signer
from vega.grpc.client import VegaCoreClient, VegaTradingDataClient
from vega.pow import solve


class TransactionFailureError(Exception):
    pass


class NoAvailablePoWBlockError(Exception):
    pass


class Client:
    def __init__(
        self,
        mnemonic: str,
        grpc_url: str,
        derivations: int = 1,
        rest_url: Optional[str] = None,
    ) -> None:
        """Create a client for signing transactions based on a given mnemonic recovery phrase.

        Args:
            mnemonic:
                str, recovery phrase used for deriving the private/public keypairs from the walley
            grpc_url:
                str, A URL for a Vega Protocol gRPC server, this will be used for querying data
                    and for sending transactions
            derivations:
                int, The derivation count from the mnemonic to use for specific key choice.
                    Each different integer will generate a unique keypair.
                    If:
                        - Generating using a mnemonic from vegawallet, the derivations index should
                            start from 1 (i.e. use 1 for the first key generated by vegawallet,
                            2 for the second etc.)
                        - Generating using a metamask mnemonic, use 0
            rest_url:
                Optional[str], default URL to use if submitting transactions over REST. If
                    submitting transactions through gRPC this is not necessary.
        """
        self._signer = Signer.from_mnemonic(mnemonic=mnemonic, derivations=derivations)

        self.grpc_url = grpc_url
        self.rest_url = rest_url

        self._trading_data_client = VegaTradingDataClient(
            self.grpc_url,
            channel=self._new_channel(),
        )
        self._core_data_client = VegaCoreClient(
            self.grpc_url,
            channel=self._new_channel(),
        )

        self._pow_blocks_used = {}
        self._block_hashes = {}

    def _new_channel(self):
        channel = grpc.insecure_channel(
            self.grpc_url,
            options=(
                ("grpc.enable_http_proxy", 0),
                ("grpc.max_send_message_length", 1024 * 1024 * 20),
                ("grpc.max_receive_message_length", 1024 * 1024 * 20),
            ),
        )
        grpc.channel_ready_future(channel).result(timeout=30)
        return channel

    def _sign_tx(
        self, serialised_input_data: bytes, chain_id: bytes
    ) -> signature_proto.Signature:
        return signature_proto.Signature(
            value=self._signer.sign(
                to_sign=chain_id
                + int(0).to_bytes(length=1, byteorder="big")
                + serialised_input_data
            ).hex(),
            algo="vega/ed25519",
            version=1,
        )

    def _calc_pow(
        self,
        block_hash: str,
        difficulty: int,
        block_height: int,
        num_past_blocks: int,
        num_tx_per_block: int,
    ) -> transaction_proto.ProofOfWork:
        tx_id = bytes(uuid.uuid4().hex, "utf-8")
        min_block = block_height - num_past_blocks + 1

        to_del_blocks = [
            historic_block
            for historic_block in self._pow_blocks_used.keys()
            if historic_block < min_block
        ]
        for block in to_del_blocks:
            del self._pow_blocks_used[block]
            del self._block_hashes[block]
        self._block_hashes[block_height] = block_hash

        block_height_to_use = block_height
        while (
            self._pow_blocks_used.setdefault(block_height_to_use, 0) >= num_tx_per_block
        ):
            block_height_to_use -= 1
        if (
            block_height_to_use < min_block
            or block_height_to_use not in self._block_hashes
        ):
            # When increasing difficulty is enabled we can do more per block by doing more PoW
            # but as first cut this will avoid bans
            raise NoAvailablePoWBlockError(
                "All seen blocks for PoW have been used. Sending a tx now would result"
                " in a ban, so wait for more blocks to be produced. "
            )
        self._pow_blocks_used[block_height_to_use] += 1

        return transaction_proto.ProofOfWork(
            tid=tx_id.decode(),
            nonce=solve(
                block_hash=self._block_hashes[block_height_to_use],
                tx_id=tx_id,
                difficulty=difficulty,
            ),
        )

    def sign_transaction(
        self,
        transaction: Any,
        transaction_type: str,
    ) -> transaction_proto.Transaction:
        """Signs and a transaction, returning a the signed object ready to submit

        Builds and submits a transaction from a command proto, with the options
        defined in the `InputData` object at
        https://docs.vega.xyz/mainnet/api/grpc/vega/commands/v1/transaction.proto#messages

        Arguments:
            transaction:
                A populated Vega Command proto from the above link
            transaction_type:
                str, the associated name from the `InputData` object
        Returns:
            Transaction, the signed and populated transaction object
        """
        res = self._core_data_client.LastBlockHeight(
            core_proto.LastBlockHeightRequest()
        )

        transaction_info = {transaction_type: transaction}
        input_data = transaction_proto.InputData(
            nonce=self._get_nonce(), block_height=res.height, **transaction_info
        )

        serialised = input_data.SerializeToString()

        return transaction_proto.Transaction(
            input_data=serialised,
            signature=self._sign_tx(
                serialised_input_data=serialised, chain_id=bytes(res.chain_id, "utf-8")
            ),
            pub_key=self._signer._pub_key,
            version=3,
            pow=self._calc_pow(
                block_hash=res.hash,
                difficulty=res.spam_pow_difficulty,
                block_height=res.height,
                num_past_blocks=res.spam_pow_number_of_past_blocks,
                num_tx_per_block=res.spam_pow_number_of_tx_per_block,
            ),
        )

    def submit_transaction(
        self,
        transaction: Any,
        transaction_type: str,
    ) -> core_proto.SubmitTransactionResponse:
        """Signs and submits a transaction over gRPC, returning a response object

        Builds and submits a transaction from a command proto, with the options
        defined in the `InputData` object at
        https://docs.vega.xyz/mainnet/api/grpc/vega/commands/v1/transaction.proto#messages

        Arguments:
            transaction:
                A populated Vega Command proto from the above link
            transaction_type:
                str, the associated name from the `InputData` object
        Returns:
            SubmitTransactionResponse, the response from the server on transaction submission
        """
        signed_tx = self.sign_transaction(
            transaction=transaction, transaction_type=transaction_type
        )

        return self._core_data_client.SubmitTransaction(
            core_proto.SubmitTransactionRequest(
                tx=signed_tx, type=core_proto.SubmitTransactionRequest.Type.TYPE_SYNC
            )
        )

    def submit_transaction_rest(
        self,
        transaction: Any,
        transaction_type: str,
        url: Optional[str] = None,
    ) -> requests.Response:
        """Signs and submits a transaction over REST, returning a standard response
        object. An alternative to the `submit_transaction` function.

        Builds and submits a transaction from a command proto, with the options
        defined in the `InputData` object at
        https://docs.vega.xyz/mainnet/api/grpc/vega/commands/v1/transaction.proto#messages

        Arguments:
            transaction:
                A populated Vega Command proto from the above link
            transaction_type:
                str, the associated name from the `InputData` object
            url:
                Optional str, If not assigned at class creation time, or if an
                override is desired, the url to which to submit the transaction.
        Returns:
            requests.Response, the response from the server on transaction submission
        """
        url = url if url is not None else self.rest_url
        if url is None:
            raise Exception(
                "URL not passed to method, nor was a default set when creating the"
                " class. At least one must be set"
            )

        signed_tx = self.sign_transaction(
            transaction=transaction, transaction_type=transaction_type
        )
        return requests.post(
            json=self.transaction_to_json(signed_tx), url=f"{url}/transaction/raw"
        )

    @staticmethod
    def _transaction_to_json(transaction: Any) -> Dict[str, str]:
        return {
            "tx": str(
                base64.b64encode(transaction.SerializeToString()).decode("utf-8")
            ),
            "type": "TYPE_SYNC",
        }

    def _get_nonce(self) -> int:
        return random.randint(1, int(1e10))
