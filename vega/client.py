import random
import grpc
import uuid
from typing import Any

import vega.proto.vega.api.v1.core_pb2 as core_proto
import vega.proto.vega.commands.v1.signature_pb2 as signature_proto
import vega.proto.vega.commands.v1.transaction_pb2 as transaction_proto
from vega.auth import Signer
from vega.pow import solve
from vega.grpc.client import VegaCoreClient, VegaTradingDataClient


class TransactionFailureError(Exception):
    pass


class NoAvailablePoWBlockError(Exception):
    pass


class Client:
    def __init__(self, mnemonic: str, grpc_url: str, derivations: int = 1) -> None:
        """Create a client for signing transactions based on a given mnemonic recovery phrase.

        Args:
            mnemonic:
                str, recovery phrase used for deriving the private/public keypairs from the walley
            grpc_url:
                str, A URL for a Vega Protocol gRPC server, this will be used for querying data
                    and for sending transactions
            derivations:
                int, The derivation count from the mnemonic to use for specific key choice.
                    Each different integer will generate a unique keypair.
                    If:
                        - Generating using a mnemonic from vegawallet, the derivations index should
                            start from 1 (i.e. use 1 for the first key generated by vegawallet,
                            2 for the second etc.)
                        - Generating using a metamask mnemonic, use 0
        """
        self._signer = Signer.from_mnemonic(mnemonic=mnemonic, derivations=derivations)

        self.grpc_url = grpc_url

        self._trading_data_client = VegaTradingDataClient(
            self.grpc_url,
            channel=self._new_channel(),
        )
        self._core_data_client = VegaCoreClient(
            self.grpc_url,
            channel=self._new_channel(),
        )

        self._starting_block_height = self._core_data_client.LastBlockHeight(
            core_proto.LastBlockHeightRequest()
        ).height

        self._pow_blocks_used = {}
        self._block_hashes = {}

    def _new_channel(self):
        channel = grpc.insecure_channel(
            self.grpc_url,
            options=(
                ("grpc.enable_http_proxy", 0),
                ("grpc.max_send_message_length", 1024 * 1024 * 20),
                ("grpc.max_receive_message_length", 1024 * 1024 * 20),
            ),
        )
        grpc.channel_ready_future(channel).result(timeout=30)
        return channel

    def _sign_tx(
        self, serialised_input_data: bytes, chain_id: bytes
    ) -> signature_proto.Signature:
        return signature_proto.Signature(
            value=self._signer.sign(
                to_sign=chain_id
                + int(0).to_bytes(length=1, byteorder="big")
                + serialised_input_data
            ).hex(),
            algo="vega/ed25519",
            version=1,
        )

    def _calc_pow(
        self,
        block_hash: str,
        difficulty: int,
        block_height: int,
        num_past_blocks: int,
        num_tx_per_block: int,
    ) -> (transaction_proto.ProofOfWork, int):
        tx_id = bytes(uuid.uuid4().hex, "utf-8")
        min_block = max(block_height - num_past_blocks + 5, self._starting_block_height)

        to_del_blocks = [
            historic_block
            for historic_block in self._pow_blocks_used.keys()
            if historic_block < min_block
        ]
        for block in to_del_blocks:
            del self._pow_blocks_used[block]
            del self._block_hashes[block]
        self._block_hashes[block_height] = block_hash

        block_height_to_use = block_height
        while (
            self._pow_blocks_used.setdefault(block_height_to_use, 0) >= num_tx_per_block
        ):
            block_height_to_use -= 1
            if block_height_to_use < min_block:
                break
        if (
            block_height_to_use < min_block
            or block_height_to_use not in self._block_hashes
        ):
            # No easy blocks left so just use latest block and a harder
            # difficulty will apply
            block_height_to_use = block_height

        self._pow_blocks_used[block_height_to_use] += 1

        return (
            transaction_proto.ProofOfWork(
                tid=tx_id.decode(),
                nonce=solve(
                    block_hash=self._block_hashes[block_height_to_use],
                    tx_id=tx_id,
                    difficulty=difficulty
                    + self._pow_blocks_used[block_height_to_use] // num_tx_per_block,
                ),
            ),
            block_height_to_use,
        )

    def sign_transaction(
        self,
        transaction: Any,
        transaction_type: str,
    ) -> core_proto.SubmitTransactionResponse:
        res = self._core_data_client.LastBlockHeight(
            core_proto.LastBlockHeightRequest()
        )

        pow_val, height_to_use = self._calc_pow(
            block_hash=res.hash,
            difficulty=res.spam_pow_difficulty,
            block_height=res.height,
            num_past_blocks=res.spam_pow_number_of_past_blocks,
            num_tx_per_block=res.spam_pow_number_of_tx_per_block,
        )

        transaction_info = {transaction_type: transaction}
        input_data = transaction_proto.InputData(
            nonce=self._get_nonce(), block_height=height_to_use, **transaction_info
        )

        serialised = input_data.SerializeToString()

        return transaction_proto.Transaction(
            input_data=serialised,
            signature=self._sign_tx(
                serialised_input_data=serialised, chain_id=bytes(res.chain_id, "utf-8")
            ),
            pub_key=self._signer._pub_key,
            version=3,
            pow=pow_val,
        )

    def submit_transaction(
        self,
        transaction: Any,
        transaction_type: str,
    ) -> core_proto.SubmitTransactionResponse:
        signed_tx = self.sign_transaction(
            transaction=transaction, transaction_type=transaction_type
        )

        return self._core_data_client.SubmitTransaction(
            core_proto.SubmitTransactionRequest(
                tx=signed_tx, type=core_proto.SubmitTransactionRequest.Type.TYPE_SYNC
            )
        )

    def _get_nonce(self) -> int:
        return random.randint(1, int(1e10))
